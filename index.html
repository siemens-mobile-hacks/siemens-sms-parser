<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Siemens SMS Archive Parser</title>
  <script type="module" src="sms-parser.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>

  <style>
    /* ---------- Base layout ---------- */
    body{font-family:Arial, sans-serif; margin:20px; line-height:1.45;}
    h1{color:#333; margin-top:0;}

    /* ---------- Pretty buttons ---------- */
    input[type="file"]{display:none;}            /* hide native inputs */
    .file-btn{
      display:inline-flex; align-items:center; gap:0.5em;
      padding:0.6em 1.2em; font-size:1em;
      background:#1976d2; color:#fff; border:none; border-radius:6px;
      cursor:pointer; transition:background .2s;
      margin:0.4em 0;
      .loading & {
        display: none;
      }
    }
    .loader {
      display: none;
      .loading & {
        display: block;
      }
    }
    .file-btn:hover{background:#1565c0;}

    /* ---------- Message bubbles ---------- */
    .message{margin:0.5em 0; padding:0.5em; border-radius:8px; border:1px solid #ccc; word-wrap:break-word;}
    .incoming{background:#f1f8e9;}
    .outgoing{background:#e3f2fd;}
    .date-header{background:#fafafa; padding:0.3em 0.5em; margin-top:0.5em; border-left:4px solid #90caf9;}

    /* ---------- Collapsible phone sections ---------- */
    details{margin-bottom:1em;}
    summary{
      cursor:pointer; font-size:1.05em; font-weight:600;
      list-style:none;
      display:flex; align-items:center; gap:0.4em;
    }
    summary::-webkit-details-marker{display:none;}
    summary::before{
      font-family:"Font Awesome 6 Free"; font-weight:900;
      content:"\f0da";
      transition:transform .2s;
    }
    details[open] summary::before{transform:rotate(90deg);}
  </style>
</head>
<body>
<h1>Siemens SMS Archive Parser</h1>
<p>Everything is parsed locally in your browser, no data is sent to the server</p>
<div id="pickerContainer">
  <!-- Directory picker -->
  <label class="file-btn" for="dirInput">
    <i class="fa-solid fa-folder-open"></i> Pick a directory with SMS Archive/SMS.dat files
  </label>
  <input type="file" id="dirInput" webkitdirectory directory multiple />

  <!-- Single-file picker -->
  <label class="file-btn" for="fileInput">
    <i class="fa-solid fa-file-import"></i> Pick a single SMS Archive/SMS.dat file
  </label>
  <input type="file" id="fileInput" />
</div>
<div class="loader">Loading...</div>
<div id="resultsContainer"></div>

<script type="module">
  import { SMSDecoder, SMSDatParser } from './sms-parser.js';

  const fileInput  = document.getElementById("fileInput");
  const dirInput   = document.getElementById("dirInput");
  const resultsDiv = document.getElementById("resultsContainer");

  /* Keep <br>s in message bodies */
  const nl2br = (str) =>
          (str ?? '').replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g,'$1<br>$2');

  const formatTimestampToIsoWithOffset = function (dateOrTimestamp, customOffsetMinutes) {
    const inputDate = dateOrTimestamp instanceof Date
            ? new Date(dateOrTimestamp.getTime())
            : new Date(dateOrTimestamp);

    const utcMillis = inputDate.getTime();                      // absolute moment in time

    let offsetMinutes;
    let localDate;

    if (typeof customOffsetMinutes === 'number') {
      offsetMinutes = customOffsetMinutes;
      localDate = new Date(utcMillis + offsetMinutes * 60_000); // shift into requested zone
    } else {
      localDate = inputDate;                                    // keep host zone
      offsetMinutes = -localDate.getTimezoneOffset();           // JS offset sign is opposite of ISO-8601
    }

    const pad = (value, length = 2) => String(Math.abs(value)).padStart(length, '0');

    const year    = localDate.getUTCFullYear();
    const month   = pad(localDate.getUTCMonth() + 1);
    const day     = pad(localDate.getUTCDate());
    const hours   = pad(localDate.getUTCHours());
    const minutes = pad(localDate.getUTCMinutes());
    const seconds = pad(localDate.getUTCSeconds());

    const sign            = offsetMinutes >= 0 ? '+' : '-';
    const absOffset       = Math.abs(offsetMinutes);
    const offsetHours     = pad(Math.floor(absOffset / 60));
    const offsetRemaining = pad(absOffset % 60);

    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${sign}${offsetHours}:${offsetRemaining}`;
  };
  /* Trigger parsing whenever files are chosen */
  fileInput.addEventListener("change", parseSelected);
  dirInput.addEventListener("change", parseSelected);

  async function parseSelected(){
    const files = [...dirInput.files, ...fileInput.files];
    if (!files.length){ return; }  // nothing picked yet
    document.querySelector('body').classList.add("loading");
    const grouped = {};

    /* --- Decode every file --- */
    for (const file of files){
      try{
        const arrayBuffer = await file.arrayBuffer();
        let messages;
        if (file.name.endsWith(".dat")) {
          const decoder = new SMSDatParser();
          messages = decoder.decode(new Uint8Array(arrayBuffer));
        } else {
          const decoder = new SMSDecoder();
          messages = [decoder.decode(new Uint8Array(arrayBuffer))];
        }

        for (const msg of messages) {
          const phone = msg.type === "Incoming"
                  ? msg.sender
                  : msg.recipient || "Unknown";

          msg.file = file
          grouped[phone] ??= [];
          grouped[phone].push(msg);
        }
      }catch(e){
        console.error(`Failed to parse file ${file.name}:`, e);
      }
    }

    resultsDiv.innerHTML = renderGrouped(grouped);
    document.querySelector('body').classList.remove("loading");
  }

  /* --- Build the result HTML --- */
  function renderGrouped(grouped){
    const phones = Object.keys(grouped)
            .sort((a,b)=>a.localeCompare(b,undefined,{numeric:true}));
    if(!phones.length) return "<p>No valid SMS data found.</p>";

    return phones.map(phone=>{
      const messages = grouped[phone].sort(function (msg1, msg2) {
        if (msg1.file.name === msg2.file.name && msg1.messageIndex !== undefined && msg2.messageIndex !== undefined) {
          return msg1.messageIndex > msg2.messageIndex ? 1: -1;
        }
        if (msg1.dateAndTimeZoneOffset !== undefined && msg2.dateAndTimeZoneOffset !== undefined) {
          return msg1.dateAndTimeZoneOffset.date > msg2.dateAndTimeZoneOffset.date ? 1 : -1;
        }
        if (msg1.dateAndTimeZoneOffset !== undefined && msg2.file.lastModified !== undefined) {
          return msg1.dateAndTimeZoneOffset.date > msg2.file.lastModified ? 1 : -1;
        }
        if (msg1.file.lastModified !== undefined && msg2.dateAndTimeZoneOffset !== undefined) {
          return msg1.file.lastModified > msg2.dateAndTimeZoneOffset.date ? 1 : -1;
        }
        if (msg1.file.lastModified !== undefined && msg2.file.lastModified !== undefined) {
          return msg1.file.lastModified > msg2.file.lastModified ? 1 : -1;
        }
        return msg1.file.name.localeCompare(msg2.file.name);
      });
      let phoneInner = "";
      messages.forEach(msg=>{
        const cls = msg.type === "Incoming" ? "incoming" : "outgoing";
        let fileMtime = '';
        if (msg.file.lastModified !== undefined) {
          fileMtime = ' (File modtime: ' + formatTimestampToIsoWithOffset(msg.file.lastModified) + ')';
        }
        let messageTime = 'Unknow date';
        if (msg.dateAndTimeZoneOffset !== undefined) {
          messageTime = formatTimestampToIsoWithOffset(msg.dateAndTimeZoneOffset.date, msg.dateAndTimeZoneOffset.timeZoneOffsetMinutes);
        }

        phoneInner += `
          <div class="message ${cls}">
            <strong>${msg.type}</strong> – ${messageTime} <strong>${msg.file.webkitRelativePath || msg.file.name}${msg.messageIndex === undefined ? '' : '#' + msg.messageIndex}</strong>${fileMtime}<br/>
            <em>${msg.encoding}</em> – SMSC: ${msg.smsCenterNumber || "N/A"}<br/>
            <div>${nl2br(msg.text)}</div>
          </div>`;
      });

      const openAttr = messages.length <= 10 ? " open" : "";
      return `
        <details${openAttr}>
          <summary>Messages with: ${phone} (${messages.length})</summary>
          ${phoneInner}
        </details>`;
    }).join("");
  }
</script>
</body>
</html>
